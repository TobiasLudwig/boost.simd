<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.13"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.smartmenus/1.0.1/jquery.smartmenus.js"></script>
        <title>Boost.SIMD: Distance between Points Part 1</title>
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
        <link rel="icon" href="numscale_icon.png">
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="ns.css" rel="stylesheet" type="text/css"/>
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="ns.js"></script>
        <script type="text/javascript" src="custom.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header responsive-logo"/>
                    <a class="navbar-brand" href="http://developer.numscale.com/">
                        <span>Boost.SIMD</span>
                    </a>
                </div>
                <div class="collapse navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li id="version">
                            <a href="#" class="disabled">4.17.6.0</a>
                        </li>
                    </ul>
                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a target="_blank" id="right-logo" href="http://www.numscale.com/" title="Numscale">
                                <img height=60 src="numscale.png" alt="Numscale">
                            </a>
                        </li>
                    </ul>
                </div><!-- /.navbar-collapse -->
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 35px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Distance between Points Part 1 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#distance-objectives">Objectives</a></li>
<li class="level1"><a href="#distance-intro">Distance between two points</a><ul><li class="level2"><a href="#distance-simd">The SIMD Calculation</a></li>
<li class="level2"><a href="#distance-interleave">How to deal with input data which is not properly ordered</a></li>
</ul>
</li>
<li class="level1"><a href="#distance-speed-up">Measuring the speed up</a></li>
<li class="level1"><a href="#distance-performance-analysis">Performance analysis</a></li>
<li class="level1"><a href="#distance-full-code">Full code</a></li>
</ul>
</div>
<div class="textblock"><div style="text-align: right;" markdown="1">Prev: <a class="el" href="tutorial-runtime.html">Runtime Extension Selection</a></div> <div style="text-align: right;" markdown="1">Next: <a class="el" href="tutorial-distance-hypot.html">Distance between 2D Points Part 2</a></div><p>In this tutorial we will examine how to calculate the Cartesian distance between a 2D reference point and a vector of 2D points. This could be used for example in a clustering algorithm such as dbscan.</p>
<h1><a class="anchor" id="distance-objectives"></a>
Objectives</h1>
<hr/>
<p>In this tutorial we will:</p><ul>
<li><a href="#distance-intro">Introduce the Boost.SIMD vectorized versions of standard library functions</a></li>
<li><a href="#distance-simd">Demonstrate how to achieve significant speed up of expensive calculations using Boost.SIMD</a></li>
<li><a href="#distance-interleave">Show you how to use data which is not in the required order</a></li>
<li><a href="#distance-speed-up">Show how to measure the speed up achieved using Boost.SIMD</a></li>
<li><a href="#distance-performance-analysis">Introduce detailed performance analysis</a></li>
</ul>
<h1><a class="anchor" id="distance-intro"></a>
Distance between two points</h1>
<p>The distance between two points </p><p class="formulaDsp">
\[(x_1,y_1), (x_2,y_2)\]
</p>
<p> in the Cartesian plane is calculated as follows:</p>
<center> \(\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}\).</center><p>We can see that we must use the standard library functions <code>std::sqrt</code> and <code>std::pow</code> in this calculation. So, in order to vectorize this code, we require vectorized versions of these functions. We wish to vectorize the following scalar code</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_points; ++i) {</div><div class="line">    <span class="keyword">auto</span> x       = refX - X[i];</div><div class="line">    <span class="keyword">auto</span> y       = refY - Y[i];</div><div class="line">    distance0[i] = <a class="code" href="group__group-arithmetic_gad9e0c99d40f784f214a728ab53139d15.html#gad9e0c99d40f784f214a728ab53139d15">std::sqrt</a>(x * x + y * y);</div><div class="line">  }</div></div><!-- fragment --> <h2><a class="anchor" id="distance-simd"></a>
The SIMD Calculation</h2>
<p>We first declare our input data. The X and Y coordinates are stored in two separate vectors. These vectors are assumed to be filled with the correct input data.</p>
<div class="fragment"><div class="line">  std::size_t num_points = 1600000;</div><div class="line">  std::vector&lt;T, bs::allocator&lt;T&gt;&gt; X(num_points);</div><div class="line">  std::vector&lt;T, bs::allocator&lt;T&gt;&gt; Y(num_points);</div><div class="line">  std::vector&lt;T, bs::allocator&lt;T&gt;&gt; distance0(num_points);</div><div class="line">  std::vector&lt;T, bs::allocator&lt;T&gt;&gt; distance1(num_points);</div><div class="line">  std::vector&lt;T, bs::allocator&lt;T&gt;&gt; distance2(num_points);</div><div class="line">  std::vector&lt;T, bs::allocator&lt;T&gt;&gt; distance3(num_points);</div><div class="line"></div><div class="line">  <a class="code" href="group__group-algo_ga563187fbb7a566cdee050dba990f5174.html#ga563187fbb7a566cdee050dba990f5174">std::generate</a>(X.begin(), X.end(),</div><div class="line">                []() { <span class="keywordflow">return</span> T(std::rand()) / <a class="code" href="group__group-arithmetic_ga38b0a4d86cba6e5acf01538a8f0d8b7d.html#ga38b0a4d86cba6e5acf01538a8f0d8b7d">std::numeric_limits&lt;int&gt;::max</a>(); });</div><div class="line">  <a class="code" href="group__group-algo_ga563187fbb7a566cdee050dba990f5174.html#ga563187fbb7a566cdee050dba990f5174">std::generate</a>(Y.begin(), Y.end(),</div><div class="line">                []() { <span class="keywordflow">return</span> T(std::rand()) / <a class="code" href="group__group-arithmetic_ga38b0a4d86cba6e5acf01538a8f0d8b7d.html#ga38b0a4d86cba6e5acf01538a8f0d8b7d">std::numeric_limits&lt;int&gt;::max</a>(); });</div><div class="line"></div><div class="line">  T refX = 0, refY = 0;</div></div><!-- fragment --> <dl class="section note">
<dt>Note</dt>
<dd>We use aligned memory to ensure correct behaviour and highest performance</dd>
</dl>
<p><b>Boost.SIMD</b> comes with many useful functions for performing vectorized computations. In this example we use the <code>+</code>, <code>-</code>, <code>sqr</code> and <code>sqrt</code> functions. The <code>sqr</code> functions calculates the square of each element of a <b>SIMD</b> vector. The first step is to fill a <code>pack_t</code> with the X and Y coordinates of the reference point. We then apply the formula shown above for calculating the distance between two points.</p>
<div class="fragment"><div class="line">  pack_t vrefX = pack_t(refX);</div><div class="line">  pack_t vrefY = pack_t(refY);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_points; i += pack_t::static_size) {</div><div class="line">    pack_t vX  = bs::aligned_load&lt;pack_t&gt;(&amp;X[i]);</div><div class="line">    pack_t vY  = bs::aligned_load&lt;pack_t&gt;(&amp;Y[i]);</div><div class="line">    pack_t res = <a class="code" href="group__group-arithmetic_gad9e0c99d40f784f214a728ab53139d15.html#gad9e0c99d40f784f214a728ab53139d15">bs::sqrt</a>(<a class="code" href="group__group-arithmetic_ga09b536540f2f4b7df8fd8e7ba497564b.html#ga09b536540f2f4b7df8fd8e7ba497564b">bs::sqr</a>(vrefX - vX) + <a class="code" href="group__group-arithmetic_ga09b536540f2f4b7df8fd8e7ba497564b.html#ga09b536540f2f4b7df8fd8e7ba497564b">bs::sqr</a>(vrefY - vY));</div><div class="line">    <a class="code" href="namespaceboost_1_1simd.html#aaa551993873d3636d339e3ef32ffb56b">bs::aligned_store</a>(res, &amp;distance1[i]);</div><div class="line">  }</div></div><!-- fragment --> <h2><a class="anchor" id="distance-interleave"></a>
How to deal with input data which is not properly ordered</h2>
<p>In the above example, we examined the case where the input data was stored in two separate buffers, one each for the \( X\) and \( Y\) coordinates.</p>
<p>However, coordinates are often stored interleaved in memory as follows: \(x_{0}, y_0, x_1, y_1, \ldots , x_n, y_{n-1}\)</p>
<p>We could sort the input data before calculating the distance, however the cost of doing this would negate any gain from using <b>SIMD</b> instructions. To solve this problem, we use the function <a class="el" href="group__group-swar_ga101e640521cc5d30cdeb102aea4d805e.html#ga101e640521cc5d30cdeb102aea4d805e" title="This function object performs a complete deinterleaving of its arguments. ">boost::simd::deinterleave</a> to sort the data in the required order in <b>SIMD</b> register.</p>
<p>After loading the data into packs v0 and v1, they contain the following elements:</p>
<p class="formulaDsp">
\[v_{0} = x_0, y_0, x_1, y_1, \ldots , x_{\frac{c}{2}-1}, y_{\frac{c}{2}-1}\]
</p>
<p class="formulaDsp">
\[v_1 = x_{\frac{c}{2}}, y_{\frac{c}{2}}, x_{\frac{c}{2}+1}, y_{\frac{c}{2}+1}, \ldots, x_{c-1}, y_{c-1}\]
</p>
<p>where c = pack_t::static_size or the number of elements in the pack.</p>
<p>In order to efficiently calculate the distance between our reference point and all of the other points, the data must be re-ordered as follows:</p>
<p class="formulaDsp">
\[v_x = x_0, x_1, \ldots , x_{c-1} \]
</p>
<p class="formulaDsp">
\[v_y = y_0, y_1, \ldots , y_{c-1} \]
</p>
<p>This is done as follows:</p>
<div class="fragment"><div class="line">  <span class="comment">// The input vector contains interleaved X and Y data, i.e. x0, y0, x1, y1,</span></div><div class="line">  <span class="comment">// ..., xn, yn</span></div><div class="line">  std::vector&lt;T, bs::allocator&lt;T&gt;&gt; interleaved_data(num_points * 2);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_points * 2; i += 2) {</div><div class="line">    interleaved_data[i]     = X[i / 2];</div><div class="line">    interleaved_data[i + 1] = Y[i / 2];</div><div class="line">  }</div><div class="line">  t0 = high_resolution_clock::now();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_points * 2; i += pack_t::static_size * 2) {</div><div class="line">    pack_t v0 = bs::aligned_load&lt;pack_t&gt;(&amp;interleaved_data[i]);</div><div class="line">    pack_t v1 = bs::aligned_load&lt;pack_t&gt;(&amp;interleaved_data[i + pack_t::static_size]);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> V     = <a class="code" href="group__group-swar_ga101e640521cc5d30cdeb102aea4d805e.html#ga101e640521cc5d30cdeb102aea4d805e">bs::deinterleave</a>(v0, v1);</div><div class="line">    pack_t res = <a class="code" href="group__group-arithmetic_gad9e0c99d40f784f214a728ab53139d15.html#gad9e0c99d40f784f214a728ab53139d15">bs::sqrt</a>(<a class="code" href="group__group-arithmetic_ga09b536540f2f4b7df8fd8e7ba497564b.html#ga09b536540f2f4b7df8fd8e7ba497564b">bs::sqr</a>(vrefX - V[0]) + <a class="code" href="group__group-arithmetic_ga09b536540f2f4b7df8fd8e7ba497564b.html#ga09b536540f2f4b7df8fd8e7ba497564b">bs::sqr</a>(vrefY - V[1]));</div><div class="line">    <a class="code" href="namespaceboost_1_1simd.html#aaa551993873d3636d339e3ef32ffb56b">bs::aligned_store</a>(res, &amp;distance2[i / 2]);</div><div class="line">  }</div><div class="line">  t1 = high_resolution_clock::now();</div></div><!-- fragment --> <h1><a class="anchor" id="distance-speed-up"></a>
Measuring the speed up</h1>
<p>If you decide to develop software using <b>Boost.SIMD</b>, performance is clearly very important to you. Therefore, it is necessary to be able to accurately measure the speed-up achieved. In this example, we measure the time taken for the main calculation loop using the timing utilities provided by <code>std::chrono</code>. Where available, these functions use hardware timers.</p>
<div class="fragment"><div class="line">  t0 = high_resolution_clock::now();</div><div class="line">  pack_t vrefX = pack_t(refX);</div><div class="line">  pack_t vrefY = pack_t(refY);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_points; i += pack_t::static_size) {</div><div class="line">    pack_t vX  = bs::aligned_load&lt;pack_t&gt;(&amp;X[i]);</div><div class="line">    pack_t vY  = bs::aligned_load&lt;pack_t&gt;(&amp;Y[i]);</div><div class="line">    pack_t res = <a class="code" href="group__group-arithmetic_gad9e0c99d40f784f214a728ab53139d15.html#gad9e0c99d40f784f214a728ab53139d15">bs::sqrt</a>(<a class="code" href="group__group-arithmetic_ga09b536540f2f4b7df8fd8e7ba497564b.html#ga09b536540f2f4b7df8fd8e7ba497564b">bs::sqr</a>(vrefX - vX) + <a class="code" href="group__group-arithmetic_ga09b536540f2f4b7df8fd8e7ba497564b.html#ga09b536540f2f4b7df8fd8e7ba497564b">bs::sqr</a>(vrefY - vY));</div><div class="line">    <a class="code" href="namespaceboost_1_1simd.html#aaa551993873d3636d339e3ef32ffb56b">bs::aligned_store</a>(res, &amp;distance1[i]);</div><div class="line">  }</div><div class="line">  t1 = high_resolution_clock::now();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; time SIMD &quot;</span> &lt;&lt; duration_cast&lt;microseconds&gt;(t1 - t0).<a class="code" href="group__group-algo_gaaf16220b7b9dcab884c08a027cf346dc.html#gaaf16220b7b9dcab884c08a027cf346dc">count</a>() &lt;&lt; std::endl;</div></div><!-- fragment --><p> The speed-up can be then calculated by dividing the time taken for the scalar loop by the time taken by the <b>SIMD</b> loop. There are several factors to consider when measuring the performance of code. Firstly, you should ensure that the size of the input data is sufficient to fill the CPU cache. Otherwise, the cache will be "hot" one entering the second loop. This means that all of the data required to complete the calculation will already be loaded into the cache, significantly accelerating the execution of the loop. You should also run the code several times and take the average of the execution times, as this may vary significantly between runs for many reasons. In general, we are interested in the typical runtime of a section of code.</p>
<h1><a class="anchor" id="distance-performance-analysis"></a>
Performance analysis</h1>
<p>This code was run on an x86 machine with an Intel Xeon CPU E3-1240 v3 @ 3.40GHz. It was compiled using g++-6.0 with all optimizations enabled and with the flag -msse4.2. A sample size of 1600000 was used.</p>
<table align="center" width="25%" class="table-striped table-bordered">
<tr>
<th>Loop </th><th>Time ( \(\mu s\)) </th></tr>
<tr>
<td>Scalar </td><td>3174 </td></tr>
<tr>
<td>SIMD </td><td>1301 </td></tr>
<tr>
<td>SIMD Interleaved </td><td>1401 </td></tr>
</table>
<p>An SSE vector contains four floats. Therefore, we should expect the speed-up to a maximum of four. However, it is less then that. There are several reasons for this. The first is that the time taken to load the data from memory accounts for a significant amount of the total time.</p>
<p>The code was then re-compiled for AVX2 using -mavx2 flag with the following results:</p>
<table align="center" width="25%" class="table-striped table-bordered">
<tr>
<th>Loop </th><th>Time ( \(\mu s\)) </th></tr>
<tr>
<td>Scalar </td><td>3142 </td></tr>
<tr>
<td>SIMD </td><td>1364 </td></tr>
<tr>
<td>SIMD Interleaved </td><td>1575 </td></tr>
</table>
<p>Firstly, we note that as expected the scalar loop took approximately the same time as for sse4.2. However, we would expect that the <b>SIMD</b> loops would execute in half of the time as on SSE4.2 as the register size is twice as large in AVX equipped machines. In this case, the time taken is approximately constant. The answer to this question lies in the Intel processor documentation. On an SSE4.2 processor the number of cycles taken to compute the square root of a vector of single precision (sqrtps instruction) floating point number is between 10 and 14 cycles, depending on the exact processor. On AVX enabled processor, the number of cycles required to perform the same operation on an AVX vector of single precision floating point numbers is between 21 and 28 cycles. Therefore, for this particular instruction, there is little advantage in using an AVX enabled processor. Please note that this is not true for most other instructions, which generally require the same number cycles as an SSE equipped processor for the same operation.</p>
<p>We also can see that the <b>SIMD</b> interleave loop took slightly longer on AVX then on SSE. The reason for this lies in the functions supported by AVX processors. Not all SSE functions are supported by AVX processors, in this case, there is no corresponding deinterleave intrinsic on AVX. Therefore, <b>Boost.SIMD</b> splits the avx vector into two SSE vectors before performing the deinterleave operation. It is for this reason that the code takes longer to execute on AVX than on SSE.</p>
<h1><a class="anchor" id="distance-full-code"></a>
Full code</h1>
<p>Here is the full code, should you wish to compile it:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;boost/simd/function/aligned_load.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/simd/function/aligned_store.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/simd/function/deinterleave.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/simd/function/sqr.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/simd/function/sqrt.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/simd/memory/allocator.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/simd/pack.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span>std::chrono;</div><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespaceboost_1_1simd.html">bs</a> = <a class="code" href="namespaceboost_1_1simd.html">boost::simd</a>;</div><div class="line">  <span class="keyword">typedef</span> <span class="keywordtype">float</span> T;</div><div class="line">  <span class="keyword">using</span> pack_t = <a class="code" href="classboost_1_1simd_1_1pack.html">bs::pack&lt;T&gt;</a>;</div><div class="line"></div><div class="line">  std::size_t num_points = 1600000;</div><div class="line">  std::vector&lt;T, bs::allocator&lt;T&gt;&gt; X(num_points);</div><div class="line">  std::vector&lt;T, bs::allocator&lt;T&gt;&gt; Y(num_points);</div><div class="line">  std::vector&lt;T, bs::allocator&lt;T&gt;&gt; distance0(num_points);</div><div class="line">  std::vector&lt;T, bs::allocator&lt;T&gt;&gt; distance1(num_points);</div><div class="line">  std::vector&lt;T, bs::allocator&lt;T&gt;&gt; distance2(num_points);</div><div class="line">  std::vector&lt;T, bs::allocator&lt;T&gt;&gt; distance3(num_points);</div><div class="line"></div><div class="line">  <a class="code" href="group__group-algo_ga563187fbb7a566cdee050dba990f5174.html#ga563187fbb7a566cdee050dba990f5174">std::generate</a>(X.begin(), X.end(),</div><div class="line">                []() { <span class="keywordflow">return</span> T(std::rand()) / <a class="code" href="group__group-arithmetic_ga38b0a4d86cba6e5acf01538a8f0d8b7d.html#ga38b0a4d86cba6e5acf01538a8f0d8b7d">std::numeric_limits&lt;int&gt;::max</a>(); });</div><div class="line">  <a class="code" href="group__group-algo_ga563187fbb7a566cdee050dba990f5174.html#ga563187fbb7a566cdee050dba990f5174">std::generate</a>(Y.begin(), Y.end(),</div><div class="line">                []() { <span class="keywordflow">return</span> T(std::rand()) / <a class="code" href="group__group-arithmetic_ga38b0a4d86cba6e5acf01538a8f0d8b7d.html#ga38b0a4d86cba6e5acf01538a8f0d8b7d">std::numeric_limits&lt;int&gt;::max</a>(); });</div><div class="line"></div><div class="line">  T refX = 0, refY = 0;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> t0 = high_resolution_clock::now();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_points; ++i) {</div><div class="line">    <span class="keyword">auto</span> x       = refX - X[i];</div><div class="line">    <span class="keyword">auto</span> y       = refY - Y[i];</div><div class="line">    distance0[i] = <a class="code" href="group__group-arithmetic_gad9e0c99d40f784f214a728ab53139d15.html#gad9e0c99d40f784f214a728ab53139d15">std::sqrt</a>(x * x + y * y);</div><div class="line">  }</div><div class="line">  <span class="keyword">auto</span> t1 = high_resolution_clock::now();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; time scalar &quot;</span> &lt;&lt; duration_cast&lt;microseconds&gt;(t1 - t0).<a class="code" href="group__group-algo_gaaf16220b7b9dcab884c08a027cf346dc.html#gaaf16220b7b9dcab884c08a027cf346dc">count</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  t0 = high_resolution_clock::now();</div><div class="line">  pack_t vrefX = pack_t(refX);</div><div class="line">  pack_t vrefY = pack_t(refY);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_points; i += pack_t::static_size) {</div><div class="line">    pack_t vX  = bs::aligned_load&lt;pack_t&gt;(&amp;X[i]);</div><div class="line">    pack_t vY  = bs::aligned_load&lt;pack_t&gt;(&amp;Y[i]);</div><div class="line">    pack_t res = <a class="code" href="group__group-arithmetic_gad9e0c99d40f784f214a728ab53139d15.html#gad9e0c99d40f784f214a728ab53139d15">bs::sqrt</a>(<a class="code" href="group__group-arithmetic_ga09b536540f2f4b7df8fd8e7ba497564b.html#ga09b536540f2f4b7df8fd8e7ba497564b">bs::sqr</a>(vrefX - vX) + <a class="code" href="group__group-arithmetic_ga09b536540f2f4b7df8fd8e7ba497564b.html#ga09b536540f2f4b7df8fd8e7ba497564b">bs::sqr</a>(vrefY - vY));</div><div class="line">    <a class="code" href="namespaceboost_1_1simd.html#aaa551993873d3636d339e3ef32ffb56b">bs::aligned_store</a>(res, &amp;distance1[i]);</div><div class="line">  }</div><div class="line">  t1 = high_resolution_clock::now();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; time SIMD &quot;</span> &lt;&lt; duration_cast&lt;microseconds&gt;(t1 - t0).<a class="code" href="group__group-algo_gaaf16220b7b9dcab884c08a027cf346dc.html#gaaf16220b7b9dcab884c08a027cf346dc">count</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="comment">// The input vector contains interleaved X and Y data, i.e. x0, y0, x1, y1,</span></div><div class="line">  <span class="comment">// ..., xn, yn</span></div><div class="line">  std::vector&lt;T, bs::allocator&lt;T&gt;&gt; interleaved_data(num_points * 2);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_points * 2; i += 2) {</div><div class="line">    interleaved_data[i]     = X[i / 2];</div><div class="line">    interleaved_data[i + 1] = Y[i / 2];</div><div class="line">  }</div><div class="line">  t0 = high_resolution_clock::now();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_points * 2; i += pack_t::static_size * 2) {</div><div class="line">    pack_t v0 = bs::aligned_load&lt;pack_t&gt;(&amp;interleaved_data[i]);</div><div class="line">    pack_t v1 = bs::aligned_load&lt;pack_t&gt;(&amp;interleaved_data[i + pack_t::static_size]);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> V     = <a class="code" href="group__group-swar_ga101e640521cc5d30cdeb102aea4d805e.html#ga101e640521cc5d30cdeb102aea4d805e">bs::deinterleave</a>(v0, v1);</div><div class="line">    pack_t res = <a class="code" href="group__group-arithmetic_gad9e0c99d40f784f214a728ab53139d15.html#gad9e0c99d40f784f214a728ab53139d15">bs::sqrt</a>(<a class="code" href="group__group-arithmetic_ga09b536540f2f4b7df8fd8e7ba497564b.html#ga09b536540f2f4b7df8fd8e7ba497564b">bs::sqr</a>(vrefX - V[0]) + <a class="code" href="group__group-arithmetic_ga09b536540f2f4b7df8fd8e7ba497564b.html#ga09b536540f2f4b7df8fd8e7ba497564b">bs::sqr</a>(vrefY - V[1]));</div><div class="line">    <a class="code" href="namespaceboost_1_1simd.html#aaa551993873d3636d339e3ef32ffb56b">bs::aligned_store</a>(res, &amp;distance2[i / 2]);</div><div class="line">  }</div><div class="line">  t1 = high_resolution_clock::now();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; time SIMD de-interleave &quot;</span> &lt;&lt; duration_cast&lt;microseconds&gt;(t1 - t0).<a class="code" href="group__group-algo_gaaf16220b7b9dcab884c08a027cf346dc.html#gaaf16220b7b9dcab884c08a027cf346dc">count</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> <div style="text-align: right;" markdown="1">Prev: <a class="el" href="tutorial-runtime.html">Runtime Extension Selection</a></div> <div style="text-align: right;" markdown="1">Next: <a class="el" href="tutorial-distance-hypot.html">Distance between 2D Points Part 2</a></div> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <hr class="footer"/>
        <address class="footer">
            <small>
                Generated on Fri Jun 9 2017 10:01:40 for Boost.SIMD by &#160;
                <a href="http://www.doxygen.org/index.html">
                    <img class="footer" src="doxygen.png" alt="doxygen"/>
                </a>
                1.8.13
            </small>
        </address>
    </body>
</html>
