<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.13"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.smartmenus/1.0.1/jquery.smartmenus.js"></script>
        <title>Boost.SIMD: Writing a dot product the SIMD way</title>
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
        <link rel="icon" href="numscale_icon.png">
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="ns.css" rel="stylesheet" type="text/css"/>
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <script type="text/javascript" src="ns.js"></script>
        <script type="text/javascript" src="custom.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header responsive-logo"/>
                    <a class="navbar-brand" href="http://developer.numscale.com/">
                        <span>Boost.SIMD</span>
                    </a>
                </div>
                <div class="collapse navbar-collapse">
                    <ul class="nav navbar-nav">
                        <li id="version">
                            <a href="#" class="disabled">4.17.6.0</a>
                        </li>
                    </ul>
                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a target="_blank" id="right-logo" href="http://www.numscale.com/" title="Numscale">
                                <img height=60 src="numscale.png" alt="Numscale">
                            </a>
                        </li>
                    </ul>
                </div><!-- /.navbar-collapse -->
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 35px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Writing a dot product the SIMD way </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tutorial-dot-objectives">Objectives</a></li>
<li class="level1"><a href="#tutorial-dot-intro">Transforming a scalar reduction into a SIMD reduction</a><ul><li class="level2"><a href="#tutorial-dot-transition">Transition from scalar to SIMD code</a></li>
<li class="level2"><a href="#tutorial-dot-simd">Building a SIMD loop</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><div style="text-align: right;" markdown="1">Prev: <a class="el" href="tutorial-mathematical.html">Using Mathematical Functions</a></div> <div style="text-align: right;" markdown="1">Next: <a class="el" href="tutorial-branching.html">SIMD Branching</a></div><p>In this tutorial we will show how data can be processed using <b>Boost.SIMD</b> by writing a naive dot product using <b>Boost.SIMD</b>.</p>
<h1><a class="anchor" id="tutorial-dot-objectives"></a>
Objectives</h1>
<hr/>
<p>In this tutorial we will:</p><ul>
<li><a href="#tutorial-dot-intro">Calculate the dot product of two vectors</a></li>
<li><a href="#tutorial-dot-transition">Arbitrarily unroll a scalar dot product</a></li>
<li><a href="#tutorial-dot-simd">Build the corresponding SIMD loop</a></li>
</ul>
<h1><a class="anchor" id="tutorial-dot-intro"></a>
Transforming a scalar reduction into a SIMD reduction</h1>
<hr/>
<p>This tutorial will present how data can be processed using <b>Boost.SIMD</b> by writing a naive dot product using <b>Boost.SIMD</b>.</p>
<p>A simple sequential, scalar dot product could be coded like this:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value&gt;</div><div class="line"><a class="code" href="struct_value.html">Value</a> <a class="code" href="group__group-reduction_ga93e42b3d9c8a8e6725f03420c2ee5e78.html#ga93e42b3d9c8a8e6725f03420c2ee5e78">dot</a>(<a class="code" href="struct_value.html">Value</a>* first1, <a class="code" href="struct_value.html">Value</a>* last1, <a class="code" href="struct_value.html">Value</a>* first2)</div><div class="line">{</div><div class="line">  <a class="code" href="struct_value.html">Value</a> v(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; first1 &lt; last1; ++first1, ++first2) {</div><div class="line">    v += (*first1) * (*first2);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> v;</div><div class="line">}</div></div><!-- fragment --><p> dot simply iterates over data pointed by first1 and first2, computes the product of this data and then sums them.</p>
<h2><a class="anchor" id="tutorial-dot-transition"></a>
Transition from scalar to SIMD code</h2>
<p>In this case the algorithm is clearly vectorizable, let's unroll the loop arbitrarily to show the inherent data parallelism:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value&gt;</div><div class="line"><a class="code" href="struct_value.html">Value</a> <a class="code" href="group__group-reduction_ga93e42b3d9c8a8e6725f03420c2ee5e78.html#ga93e42b3d9c8a8e6725f03420c2ee5e78">dot</a>(<a class="code" href="struct_value.html">Value</a>* first1, <a class="code" href="struct_value.html">Value</a>* last1, <a class="code" href="struct_value.html">Value</a>* first2)</div><div class="line">{</div><div class="line">  <a class="code" href="struct_value.html">Value</a> v1(0), v2(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; first1 &lt; last1;) {</div><div class="line">    v1 += (*first1) * (*first2);</div><div class="line">    ++first1;</div><div class="line">    ++first2;</div><div class="line"></div><div class="line">    v2 += (*first1) * (*first2);</div><div class="line">    ++first1;</div><div class="line">    ++first2;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> v1 + v2;</div><div class="line">}</div></div><!-- fragment --><p> The algorithm is split into two parts:</p>
<p>First, we loop over each element inside both datasets and multiply them and then, we sum the intermediate values into the final result.</p>
<p>By unrolling this pattern arbitrarily, we expose the fact that the multiplication between the two dataset is purely "vertical" and so, is vectorizable. The <a class="el" href="group__group-reduction_ga418c9174d2e31b314f003e047af12ca6.html#ga418c9174d2e31b314f003e047af12ca6" title="This function object returns the sum of the elements of the SIMD argument. ">boost::simd::sum</a> of the partial results itself is an "horizontal" operation, i.e a vectorizable computation operating across the elements of a single vector (see <a class="el" href="group__group-swar.html">Intra register Functions</a> operations).</p>
<h2><a class="anchor" id="tutorial-dot-simd"></a>
Building a SIMD loop</h2>
<p>We are now going to use <code><a class="el" href="classboost_1_1simd_1_1pack.html" title="High-level interface for manipulating SIMD data. ">boost::simd::pack</a></code> to vectorize this loop. The main idea is to compute partial sums inside an instance of <code><a class="el" href="classboost_1_1simd_1_1pack.html" title="High-level interface for manipulating SIMD data. ">boost::simd::pack</a></code> and then perform a final summation. To do so, we will use <code><a class="el" href="namespaceboost_1_1simd_a44f9b5b1a343b238a3a80a52365ec860.html#a44f9b5b1a343b238a3a80a52365ec860" title="Load a value from memory into a generic variable. ">boost::simd::load</a></code> to load data from first1 and first2, process these <code><a class="el" href="classboost_1_1simd_1_1pack.html" title="High-level interface for manipulating SIMD data. ">boost::simd::pack</a></code> instances using the proper operators and then advance the pointers by the cardinal of <code><a class="el" href="classboost_1_1simd_1_1pack.html" title="High-level interface for manipulating SIMD data. ">boost::simd::pack</a></code>.</p>
<div class="fragment"><div class="line"><a class="code" href="struct_value.html">Value</a> simddot(<a class="code" href="struct_value.html">Value</a>* first1, <a class="code" href="struct_value.html">Value</a>* last1, <a class="code" href="struct_value.html">Value</a>* first2)</div><div class="line">{</div><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespaceboost_1_1simd.html">bs</a> = <a class="code" href="namespaceboost_1_1simd.html">boost::simd</a>;</div><div class="line">  <span class="keyword">using</span> pack_t = <a class="code" href="classboost_1_1simd_1_1pack.html">bs::pack&lt;Value&gt;</a>;</div><div class="line"></div><div class="line">  pack_t tmp{0};</div><div class="line">  <span class="keywordtype">int</span> card = pack_t::static_size;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; first1 + card &lt;= last1; first1 += card, first2 += card) {</div><div class="line">    <span class="comment">// Load current values from the datasets</span></div><div class="line">    pack_t x1 = bs::load&lt;pack_t&gt;(first1);</div><div class="line">    pack_t x2 = bs::load&lt;pack_t&gt;(first2);</div><div class="line">    <span class="comment">// Computation</span></div><div class="line">    tmp = tmp + x1 * x2;</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="struct_value.html">Value</a> dot_product = <a class="code" href="group__group-reduction_ga418c9174d2e31b314f003e047af12ca6.html#ga418c9174d2e31b314f003e047af12ca6">bs::sum</a>(tmp); <span class="comment">// horizontal SIMD vector summation</span></div><div class="line">  <span class="keywordflow">for</span> (; first1 &lt; last1; ++first1, ++first2) {</div><div class="line">    dot_product += (*first1) * (*first2);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> dot_product;</div><div class="line">}</div></div><!-- fragment --><p>That's it! Look at how similar the computation code is to the scalar version, we simply jump over data using a larger step size and at the end we account for the data which does not fit inside a <b>SIMD</b> vector.</p>
<dl class="section note">
<dt>Note</dt>
<dd>The code line <code>tmp = tmp + x1 * x2;</code> may replaced by <code>tmp += x1 * x2;</code> or even <code>tmp = fma(x1, x2,tmp);</code> (after having included <code>boost/simd/function/fma.hpp</code>) which may generate even more efficient code as many processors have special instructions for performing this operation. If the target processor is not equipped such an instruction, high quality vectorized code will nevertheless be generated. </dd>
</dl>
<p>Here is a full code, should you wish to try it:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/simd/function/load.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/simd/function/sum.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;boost/simd/pack.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value&gt;</div><div class="line"><a class="code" href="struct_value.html">Value</a> scaldot(<a class="code" href="struct_value.html">Value</a>* first1, <a class="code" href="struct_value.html">Value</a>* last1, <a class="code" href="struct_value.html">Value</a>* first2)</div><div class="line">{</div><div class="line">  <a class="code" href="struct_value.html">Value</a> v(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; first1 &lt; last1; ++first1, ++first2) {</div><div class="line">    v += (*first1) * (*first2);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">return</span> v;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value&gt;</div><div class="line"><a class="code" href="struct_value.html">Value</a> simddot(<a class="code" href="struct_value.html">Value</a>* first1, <a class="code" href="struct_value.html">Value</a>* last1, <a class="code" href="struct_value.html">Value</a>* first2)</div><div class="line">{</div><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespaceboost_1_1simd.html">bs</a> = <a class="code" href="namespaceboost_1_1simd.html">boost::simd</a>;</div><div class="line">  <span class="keyword">using</span> pack_t = <a class="code" href="classboost_1_1simd_1_1pack.html">bs::pack&lt;Value&gt;</a>;</div><div class="line"></div><div class="line">  pack_t tmp{0};</div><div class="line">  <span class="keywordtype">int</span> card = pack_t::static_size;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; first1 + card &lt;= last1; first1 += card, first2 += card) {</div><div class="line">    <span class="comment">// Load current values from the datasets</span></div><div class="line">    pack_t x1 = bs::load&lt;pack_t&gt;(first1);</div><div class="line">    pack_t x2 = bs::load&lt;pack_t&gt;(first2);</div><div class="line">    <span class="comment">// Computation</span></div><div class="line">    tmp = tmp + x1 * x2;</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="struct_value.html">Value</a> dot_product = <a class="code" href="group__group-reduction_ga418c9174d2e31b314f003e047af12ca6.html#ga418c9174d2e31b314f003e047af12ca6">bs::sum</a>(tmp);</div><div class="line">  <span class="keywordflow">for</span> (; first1 &lt; last1; ++first1, ++first2) {</div><div class="line">    dot_product += (*first1) * (*first2);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> dot_product;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keyword">namespace </span><a class="code" href="namespaceboost_1_1simd.html">bs</a> = <a class="code" href="namespaceboost_1_1simd.html">boost::simd</a>;</div><div class="line">  <span class="keyword">using</span> pack_t = <a class="code" href="classboost_1_1simd_1_1pack.html">bs::pack&lt;float&gt;</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> size = 113;</div><div class="line">  <span class="keywordtype">float</span> card_float  = <a class="code" href="structboost_1_1simd_1_1cardinal__of.html">bs::cardinal_of&lt;pack_t&gt;</a>();</div><div class="line"></div><div class="line">  std::vector&lt;float&gt; v1(size), v2(size);</div><div class="line">  <a class="code" href="group__group-algo_gadb2705dba33a162bffe7656b7fe6c32c.html#gadb2705dba33a162bffe7656b7fe6c32c">std::iota</a>(v1.begin(), v1.end(), 0);</div><div class="line">  <a class="code" href="group__group-algo_gadb2705dba33a162bffe7656b7fe6c32c.html#gadb2705dba33a162bffe7656b7fe6c32c">std::iota</a>(v2.begin(), v2.end(), 1);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;scalar dot product output &quot;</span> &lt;&lt; scaldot(v1.data(), v1.data() + size, v2.data())</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;simd   dot product output &quot;</span> &lt;&lt; simddot(v1.data(), v1.data() + size, v2.data())</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">};</div><div class="line"><span class="comment">// This code can be compiled using (for instance for gcc)</span></div><div class="line"><span class="comment">// g++ dotmain.cpp -msse4.2 -std=c++11 -O3 -DNDEBUG -o dotmain</span></div><div class="line"><span class="comment">// -I/path_to/boost_simd/ -I/path_to/boost/</span></div></div><!-- fragment --> <div style="text-align: right;" markdown="1">Prev: <a class="el" href="tutorial-mathematical.html">Using Mathematical Functions</a></div> <div style="text-align: right;" markdown="1">Next: <a class="el" href="tutorial-branching.html">SIMD Branching</a></div> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <hr class="footer"/>
        <address class="footer">
            <small>
                Generated on Fri Jun 9 2017 10:01:40 for Boost.SIMD by &#160;
                <a href="http://www.doxygen.org/index.html">
                    <img class="footer" src="doxygen.png" alt="doxygen"/>
                </a>
                1.8.13
            </small>
        </address>
    </body>
</html>
